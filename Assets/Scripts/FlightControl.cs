using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class FlightControl : MonoBehaviour
{


    //USER CONTROLS***************************
    public float rollSpeed;
    public float pitchSpeed;
    public float yawSpeed;

    //PHYSICS VARIABLES******************************************************

    //The birds mass
    public Rigidbody theBird;

    //Upward and forward thrust generated by wing flaps
    public float thrustPower;
    public float upThrust;
    public float forwardThrust;



    //Air physics - Drag Resistance Applied Inverse to Velocity
    public float radius; //Radius of the flight object -- Higher equals more drag
    private float dragArea; //Area of the flight object -- in this case a sphere
    private Vector3 currentDirection;
    private float angle;
    private float resistanceFactor; // Resistance per k/m^3. Try to keep below 1
    private float maxResistance; //Per cubic meter
    private float velocityFactor;

    //Air Physics - Lift Force Inverse to Velocity
    //public float requiredAirSpeedForFlight;
    //private float lift;

    //***************************************************************************







    void Start()
    {
        SetInitialReferences();
    }

    void FixedUpdate()
    {
        LiftOff();
        DirectionalControl();

    }

    void LateUpdate()
    {
        ApplyForce();
    }

    void SetInitialReferences()
    {
        theBird = GetComponent<Rigidbody>();
    }

    void DirectionalControl()
    {
        float h = Input.GetAxis("Horizontal") * rollSpeed * Time.deltaTime;
        float v = Input.GetAxis("Vertical") * pitchSpeed * Time.deltaTime;
        float y = Input.GetAxis("Yaw") * yawSpeed * Time.deltaTime;

        theBird.AddTorque(transform.forward * -h);
        theBird.AddTorque(transform.right * v);
        theBird.AddTorque(transform.up * y);
    }


    void LiftOff()
    {
        if (Input.GetButtonDown("Jump"))
        {
            theBird.AddRelativeForce(0, upThrust, forwardThrust, ForceMode.Impulse);
            print("jump");
        }

    }

    float FindVelocityFactor()
    {

        return theBird.velocity.magnitude;

    }

    float FindResistanceFactor()
    {
        //Get the constant area and maximum resistance
        dragArea = Mathf.PI * Mathf.Pow(radius, 2);
        maxResistance = dragArea * Mathf.Pow(resistanceFactor, 3);
        currentDirection = theBird.velocity;               //Birds direction
        angle = Vector3.Angle(transform.forward, currentDirection);    //Angle between bird direction and velocity direction
        return Mathf.Abs(Mathf.Sin(angle));                        //Return the resistance factor
        return theBird.velocity.magnitude;                        //Gets and returns the birds velocity magnitude
    }

    void ApplyForce()
    {
        float magnitude = maxResistance * resistanceFactor * velocityFactor; //Magnitude of air resistance
        Vector3 direction = transform.forward.normalized * -1;  //calculate the direction
        theBird.AddRelativeForce(direction * magnitude);        //Add the force to the rigidbody
    }

    //    float LiftEquation()
    //    {
    //        if (airSpeed >= requiredAirSpeedForFlight) 
    //        {
    //            theBird.AddRelativeForce (0, lift, 0);
    //        }
    //    }
    //
    //    float DefineLift()
    //    {
    //        
    //    }
    //
    //    float FindAirSpeed()
    //    {
    //        
    //    }


}